import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from '@supabase/supabase-js';
import { categorySchema } from '@/schemas/admin';
import { z } from 'zod';

// Supabase URLs and keys
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://ktsvgjezhyrzrhghilvm.supabase.co';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt0c3ZnamV6aHlyenJoZ2hpbHZtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk2ODkwMjcsImV4cCI6MjA2NTI2NTAyN30.ragywUSW8m1l7y3HPIMGtf54reMP2Bak99M4FETG9sw';

// For admin actions, we'll use the service_role key (if available) to bypass RLS
// In production, this should be set in environment variables and never exposed to the client
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Verify admin token - this is a mock verification for development
function verifyAdminToken(token: string): boolean {
  try {
    // Check if the token has the format of a JWT (three parts separated by dots)
    const parts = token.split('.');
    if (parts.length !== 3) {
      return false;
    }
    
    // In development, we don't verify the signature, just check the structure
    // In production, you would cryptographically verify the JWT signature
    const base64Payload = parts[1].replace(/-/g, '+').replace(/_/g, '/');
    const payload = JSON.parse(Buffer.from(base64Payload, 'base64').toString());
    
    // Check if this is our admin user
    if (payload.isAdmin === true && payload.sub === 'admin-user-001') {
      return true;
    }
    
    return false;
  } catch (error) {
    console.error('Token verification error:', error);
    return false;
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Check for authorization header
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ message: "Unauthorized - Missing or invalid Authorization header" });
  }
  
  const token = authHeader.replace("Bearer ", "");
  
  try {
    // Create the appropriate Supabase client based on available keys
    // If we have a service role key, use it for admin operations (bypasses RLS)
    // Otherwise fallback to the anon key with additional options
    let supabase;
    
    if (supabaseServiceKey) {
      // Use service role key for admin operations (bypasses RLS)
      supabase = createClient(supabaseUrl, supabaseServiceKey, {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      });
      console.log('Using service role key for admin operations');
    } else {
      // Fallback to anon key - for development only
      // In development, we'll use the RLS bypass technique
      supabase = createClient(supabaseUrl, supabaseAnonKey);
      console.log('Service role key not available, using anon key');
    }
    
    // For development: verify our mock admin token
    let isAdmin = false;
    let userId = null;
    
    if (process.env.NODE_ENV !== 'production' && verifyAdminToken(token)) {
      isAdmin = true;
      userId = 'admin-user-001';
    } else {
      // For production: Verify with Supabase's built-in authentication
      try {
        // Verify the JWT token with Supabase
        const { data: userData, error: userError } = await supabase.auth.getUser(token);
        
        if (userError || !userData?.user) {
          console.error('Invalid user token:', userError);
          return res.status(401).json({ message: "Unauthorized - Invalid user token" });
        }
        
        userId = userData.user.id;
        
        // Check if the user has admin privileges in the profiles table
        const { data: profile, error: profileError } = await supabase
          .from("profiles")
          .select("is_admin")
          .eq("id", userData.user.id)
          .single();
          
        if (profileError) {
          console.error('Error fetching admin status:', profileError);
          return res.status(500).json({ message: "Internal server error during authentication" });
        }
        
        isAdmin = !!profile?.is_admin;
      } catch (authError) {
        console.error('Authentication error:', authError);
        return res.status(500).json({ message: "Internal server error during authentication" });
      }
    }
    
    if (!isAdmin) {
      return res.status(403).json({ message: "Forbidden - Admin privileges required" });
    }

    // If using anon key, we need to set up RLS bypass for admin actions
    if (!supabaseServiceKey) {
      // For development/testing without a service role key, we can use special headers
      // that may allow bypassing RLS if configured on the Supabase side
      supabase = createClient(supabaseUrl, supabaseAnonKey, {
        global: {
          headers: {
            'x-admin-authorization': 'true',
            'x-admin-user-id': userId
          }
        }
      });
    }

    // Handle CRUD operations based on HTTP method
    switch (req.method) {
      case "GET":
        return getCategories(req, res, supabase);
      case "POST":
        return createCategory(req, res, supabase);
      case "PUT":
        return updateCategory(req, res, supabase);
      case "DELETE":
        return deleteCategory(req, res, supabase);
      default:
        res.setHeader("Allow", ["GET", "POST", "PUT", "DELETE"]);
        return res.status(405).json({ message: `Method ${req.method} Not Allowed` });
    }
  } catch (error) {
    console.error('API error:', error);
    return res.status(500).json({ message: "Internal server error" });
  }
}

async function getCategories(req: NextApiRequest, res: NextApiResponse, supabase: any) {
  try {
    // Query the categories table - try categories first, then fall back to category if needed
    let result;
    
    // Try "categories" table first
    result = await supabase
      .from("categories")
      .select("id, name")
      .order("name");
    
    // If there's an error with "categories", try "category" table
    if (result.error && result.error.code === "42P01") { // table doesn't exist
      console.log('Trying alternative table name: "category"');
      result = await supabase
        .from("category")
        .select("id, name")
        .order("name");
    }
    
    if (result.error) {
      console.error('Error fetching categories:', result.error);
      throw result.error;
    }
    
    return res.status(200).json({ categories: result.data || [] });
  } catch (error: any) {
    console.error('Error fetching categories:', error);
    return res.status(500).json({ message: error.message || 'Internal server error while fetching categories' });
  }
}

async function createCategory(req: NextApiRequest, res: NextApiResponse, supabase: any) {
  try {
    // Validate input using Zod
    const parseResult = categorySchema.safeParse(req.body);
    
    if (!parseResult.success) {
      return res.status(400).json({ 
        message: "Invalid category data", 
        errors: parseResult.error.format() 
      });
    }
    
    const { name } = parseResult.data;
    
    // Determine which table to use
    let tableName = "categories";
    
    // Test if categories table exists
    const testResult = await supabase
      .from(tableName)
      .select("id")
      .limit(1);
    
    // If table doesn't exist, try category
    if (testResult.error && testResult.error.code === "42P01") {
      tableName = "category";
    }
    
    // Check if category with same name already exists (case insensitive)
    const { data: existingCategory, error: checkError } = await supabase
      .from(tableName)
      .select("id")
      .ilike("name", name)
      .maybeSingle();
    
    if (checkError) {
      console.error('Error checking existing category:', checkError);
      throw checkError;
    }
    
    if (existingCategory) {
      return res.status(409).json({ message: "A category with this name already exists." });
    }
    
    // Insert into the appropriate categories table
    const insertResult = await supabase
      .from(tableName)
      .insert([{ name }]);
    
    if (insertResult.error) {
      console.error('Error inserting category:', insertResult.error);
      // Check if it's an RLS policy error
      if (insertResult.error.message && insertResult.error.message.includes('policy')) {
        return res.status(403).json({ 
          message: "Row-level security policy prevented category creation. Administrator access required.",
          details: insertResult.error.message
        });
      }
      throw insertResult.error;
    }
    
    // Fetch the newly created category
    const { data, error } = await supabase
      .from(tableName)
      .select("id, name")
      .ilike("name", name)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching created category:', error);
      throw error;
    }
    
    return res.status(201).json({ category: data });
  } catch (error: any) {
    console.error('Error creating category:', error);
    return res.status(500).json({ 
      message: error.message || 'Internal server error while creating category',
      details: error
    });
  }
}

// The rest of the file (updateCategory and deleteCategory) remains unchanged
