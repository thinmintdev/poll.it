# Artillery Load Testing for Poll.it

This setup provides comprehensive load testing for the Poll.it application using Artillery.js.

## 🚀 Quick Start

1. **Start your development server:**
   ```bash
   npm run dev
   ```

2. **Run a quick test to verify setup:**
   ```bash
   npm run load-test:quick
   ```

3. **Run the full load test suite:**
   ```bash
   npm run load-test standard
   ```

## 📊 Available Test Types

### 1. Quick Test (`artillery-quick-test.yml`)
- **Duration:** 20 seconds
- **Load:** 5 users/second
- **Purpose:** Verify setup and basic functionality
- **Command:** `npm run load-test:quick`

### 2. Standard Load Test (`artillery-config.yml`)
- **Duration:** ~5 minutes
- **Load:** Ramps from 5 to 50 users/second with spike to 100
- **Scenarios:** 70% voting, 15% poll creation, 10% browsing, 5% results
- **Command:** `npm run load-test:standard`

### 3. Spike Test (`artillery-spike-test.yml`)
- **Duration:** 10 seconds
- **Load:** Sudden burst of 200 users/second
- **Purpose:** Test system resilience under sudden load
- **Command:** `npm run load-test:spike`

### 4. Endurance Test (`artillery-endurance-test.yml`)
- **Duration:** 10 minutes
- **Load:** Sustained 20 users/second
- **Purpose:** Test for memory leaks and long-term stability
- **Command:** `npm run load-test:endurance`

## 🛠️ Usage

### Using npm scripts:
```bash
# Individual tests
npm run load-test:quick      # Quick verification
npm run load-test:standard   # Full load test
npm run load-test:spike      # Spike test
npm run load-test:endurance  # Long-term stability

# Using the test runner (recommended)
./run-load-tests.sh standard   # Standard test
./run-load-tests.sh spike      # Spike test
./run-load-tests.sh endurance  # Endurance test
./run-load-tests.sh all        # Run all tests sequentially
```

### Direct Artillery commands:
```bash
# Generate poll IDs first
DATABASE_URL="your_db_url" node scripts/generate-poll-ids.js

# Run specific test
npx artillery run artillery-config.yml

# Run with output file for reporting
npx artillery run artillery-config.yml --output results.json

# Generate HTML report
npx artillery report results.json
```

## 📈 Understanding Results

### Key Metrics to Monitor:

1. **Response Times:**
   - `http.response_time.min/max/median`
   - Target: < 500ms for 95th percentile

2. **Request Rate:**
   - `http.requests` - Total requests per second
   - Should match configured arrival rate

3. **Error Rate:**
   - `http.codes.200` vs `http.codes.4xx/5xx`
   - Target: < 1% error rate

4. **Database Performance:**
   - Monitor connection pool usage
   - Watch for query timeouts

### Sample Output:
```
Summary report @ 15:30:42(+0000)
  Scenarios launched:  1500
  Scenarios completed: 1498
  Requests completed:  4485
  Response time (msec):
    min: 12
    max: 1250
    median: 85.5
    p95: 245.2
    p99: 458.7
  Codes:
    200: 4200
    201: 285
```

## 🔧 Configuration

### Test Parameters

Edit the `.yml` files to adjust:

- **Duration:** `phases.duration` (seconds)
- **Load:** `phases.arrivalRate` (users/second)
- **Scenarios:** `scenarios.weight` (percentage)
- **Think Time:** `think` values (seconds)

### Custom Data

The tests use realistic data generation:

- **Poll IDs:** From `scripts/poll-ids.csv`
- **Random Strings:** Generated by `artillery-processor.js`
- **User Agents:** Simulated browser requests
- **IP Addresses:** Randomized for voting simulation

## 🚨 Troubleshooting

### Common Issues:

1. **"Server not running" error:**
   ```bash
   npm run dev  # Start development server first
   ```

2. **"No polls found" error:**
   ```bash
   # Reset database with sample data
   DATABASE_URL="your_db_url" node scripts/backup-and-reset-db.js
   ```

3. **High error rates:**
   - Check database connection limits
   - Monitor server resource usage
   - Verify API endpoints are working

4. **Artillery not found:**
   ```bash
   npm install artillery --save-dev
   ```

### Performance Optimization Tips:

1. **Database:**
   - Enable connection pooling
   - Add indexes on frequently queried columns
   - Monitor connection limits

2. **Application:**
   - Enable response caching
   - Optimize database queries
   - Use CDN for static assets

3. **Infrastructure:**
   - Scale horizontally if possible
   - Monitor CPU/memory usage
   - Use production-grade database

## 📁 File Structure

```
scripts/
  ├── artillery-processor.js    # Custom functions
  ├── generate-poll-ids.js     # Generate test data
  └── poll-ids.csv            # Poll IDs for testing

artillery-config.yml          # Main load test
artillery-quick-test.yml      # Quick verification
artillery-spike-test.yml      # Spike testing
artillery-endurance-test.yml  # Long-term testing
run-load-tests.sh            # Test runner script
```

## 🎯 Production Considerations

Before running tests against production:

1. **Coordinate with team** - Notify about planned load testing
2. **Use staging environment** - Test against production-like setup
3. **Monitor infrastructure** - Watch server metrics during tests
4. **Have rollback plan** - Be prepared to stop tests if issues arise
5. **Test off-peak hours** - Minimize impact on real users

## 📊 Advanced Usage

### Custom Scenarios

Create your own test scenarios by modifying the `.yml` files:

```yaml
scenarios:
  - name: "Custom test"
    weight: 100
    flow:
      - get:
          url: "/your-endpoint"
      - think: 2
      - post:
          url: "/api/your-action"
          json:
            customData: "{{ $randomString() }}"
```

### Integration with CI/CD

Add to your GitHub Actions or other CI/CD pipeline:

```yaml
- name: Load Testing
  run: |
    npm run dev &
    sleep 10
    npm run load-test:quick
    pkill -f "next dev"
```

---

For more Artillery.js documentation, visit: https://www.artillery.io/docs
